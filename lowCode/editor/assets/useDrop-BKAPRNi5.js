import{s as h,w as f,i as T,u as a,a as g,d as D,b as I,c as m}from"./useDragDropManager-Dl0-aEZk.js";import{r as i}from"./index-DmOc0qNU.js";import{i as l}from"./shallow-DkvW6rgF.js";let s=!1;class C{receiveHandlerId(t){this.targetId=t}getHandlerId(){return this.targetId}subscribeToStateChange(t,e){return this.internalMonitor.subscribeToStateChange(t,e)}canDrop(){if(!this.targetId)return!1;l(!s,"You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");try{return s=!0,this.internalMonitor.canDropOnTarget(this.targetId)}finally{s=!1}}isOver(t){return this.targetId?this.internalMonitor.isOverTarget(this.targetId,t):!1}getItemType(){return this.internalMonitor.getItemType()}getItem(){return this.internalMonitor.getItem()}getDropResult(){return this.internalMonitor.getDropResult()}didDrop(){return this.internalMonitor.didDrop()}getInitialClientOffset(){return this.internalMonitor.getInitialClientOffset()}getInitialSourceClientOffset(){return this.internalMonitor.getInitialSourceClientOffset()}getSourceClientOffset(){return this.internalMonitor.getSourceClientOffset()}getClientOffset(){return this.internalMonitor.getClientOffset()}getDifferenceFromInitialOffset(){return this.internalMonitor.getDifferenceFromInitialOffset()}constructor(t){this.targetId=null,this.internalMonitor=t.getMonitor()}}class O{get connectTarget(){return this.dropTarget}reconnect(){const t=this.didHandlerIdChange()||this.didDropTargetChange()||this.didOptionsChange();t&&this.disconnectDropTarget();const e=this.dropTarget;if(this.handlerId){if(!e){this.lastConnectedDropTarget=e;return}t&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDropTarget=e,this.lastConnectedDropTargetOptions=this.dropTargetOptions,this.unsubscribeDropTarget=this.backend.connectDropTarget(this.handlerId,e,this.dropTargetOptions))}}receiveHandlerId(t){t!==this.handlerId&&(this.handlerId=t,this.reconnect())}get dropTargetOptions(){return this.dropTargetOptionsInternal}set dropTargetOptions(t){this.dropTargetOptionsInternal=t}didHandlerIdChange(){return this.lastConnectedHandlerId!==this.handlerId}didDropTargetChange(){return this.lastConnectedDropTarget!==this.dropTarget}didOptionsChange(){return!h(this.lastConnectedDropTargetOptions,this.dropTargetOptions)}disconnectDropTarget(){this.unsubscribeDropTarget&&(this.unsubscribeDropTarget(),this.unsubscribeDropTarget=void 0)}get dropTarget(){return this.dropTargetNode||this.dropTargetRef&&this.dropTargetRef.current}clearDropTarget(){this.dropTargetRef=null,this.dropTargetNode=null}constructor(t){this.hooks=f({dropTarget:(e,n)=>{this.clearDropTarget(),this.dropTargetOptions=n,T(e)?this.dropTargetRef=e:this.dropTargetNode=e,this.reconnect()}}),this.handlerId=null,this.dropTargetRef=null,this.dropTargetOptionsInternal=null,this.lastConnectedHandlerId=null,this.lastConnectedDropTarget=null,this.lastConnectedDropTargetOptions=null,this.backend=t}}function M(r){return i.useMemo(()=>r.hooks.dropTarget(),[r])}function b(r){const t=a(),e=i.useMemo(()=>new O(t.getBackend()),[t]);return g(()=>(e.dropTargetOptions=r||null,e.reconnect(),()=>e.disconnectDropTarget()),[r]),e}function v(){const r=a();return i.useMemo(()=>new C(r),[r])}function y(r){const{accept:t}=r;return i.useMemo(()=>(l(r.accept!=null,"accept must be defined"),Array.isArray(t)?t:[t]),[t])}class H{canDrop(){const t=this.spec,e=this.monitor;return t.canDrop?t.canDrop(e.getItem(),e):!0}hover(){const t=this.spec,e=this.monitor;t.hover&&t.hover(e.getItem(),e)}drop(){const t=this.spec,e=this.monitor;if(t.drop)return t.drop(e.getItem(),e)}constructor(t,e){this.spec=t,this.monitor=e}}function R(r,t){const e=i.useMemo(()=>new H(r,t),[t]);return i.useEffect(()=>{e.spec=r},[r]),e}function S(r,t,e){const n=a(),o=R(r,t),c=y(r);g(function(){const[p,u]=D(c,o,n);return t.receiveHandlerId(p),e.receiveHandlerId(p),u},[n,t,o,e,c.map(d=>d.toString()).join("|")])}function A(r,t){const e=I(r,t),n=v(),o=b(e.options);return S(e,n,o),[m(e.collect,n,o),M(o)]}export{A as u};
